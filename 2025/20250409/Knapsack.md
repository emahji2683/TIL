# コード

```
def knapsack(n, w_limit, weights, values)
  dp = Array.new(n + 1) { Array.new(w_limit + 1, 0) }

  (0...n).each do |i|
    (0..w_limit).each do |w|
      if w >= weights[i]
        dp[i + 1][w] = [dp[i][w], dp[i][w - weights[i]] + values[i]].max
      else
        dp[i + 1][w] = dp[i][w]
      end
    end
  end

  dp[n][w_limit]
end

# 使用例:
weights = [2, 1, 3, 2]
values  = [3, 2, 4, 2]
w_limit = 5
n = weights.length

puts knapsack(n, w_limit, weights, values)  # => 7
```

# ナップサック問題とは
動的計画法の問題の一つ。容量が決まっているナップサックに、いくつかのアイテムを選んで入れ、どの組み合わせで価値が最大になるか特定する問題。
> あなたは容量が決まっているナップサック（リュックサック）を持っています。
> 複数のアイテムがあり、それぞれ「重さ」と「価値」があります。
> この中からいくつかのアイテムを選んで、ナップサックに詰めます。
> ナップサックの容量を超えないようにしながら、価値の合計が最大になるようにしたい！

# 前提知識
## 動的計画法(DP)
対象となる問題を複数の部分問題に分割・計算・記録することで、大問題の解決に使用する手法のこと。ナップサック問題においては、特定の最大重量、範囲の結果を部分問題として、解決・記録・使用することで、全体の問題の解決を行っている。
> 動的計画法（どうてきけいかくほう、英: Dynamic Programming, DP）は、計算機科学の分野において、アルゴリズムの分類の1つである。対象となる問題を複数の部分問題に分割し、部分問題の計算結果の記録を利用して全体の問題を解く手法を総称してこう呼ぶ。 

# パラメーター
あるサンプルコードに示されている、パラメーターについて以下に記述する。
- `i`: 使用するアイテム群の番号の上限
- `w`: 現在の容量
- `weight[i]`: i+1番目のアイテムの重量
- `values[i]`: i+1番目のアイテムの価値
- `w - weight[i - 1]`: i番目のアイテムの重量と現在の容量の差分。これがマイナスになるとナップサックの中にi番目のアイテムを入れられない。
- `dp[i][w]`: 最大容量w前提で0~i-1番目の任意の数のアイテムを投入したパターンの内、価値が最大になるパターン。
- `dp[i+1][w]`: i+1番目の品物までを使って最大容量wの場合の最大容量。

`dp[i+1][w]`はどうやって決まる?⇨i番目の品物をナップサックに入れるか入れないかによってきまる。
i番目の品物を入れないならば、`dp[i][x]`の中身は変わらないので



```
for i in 1..n
  for w in 1..capacity
```
あるi(使用するアイテムの範囲)における、それぞれのw(最大容量)

```
  (0...n).each do |i|
    (0..w_limit).each do |w|
      if w >= weights[i]
        dp[i + 1][w] = [dp[i][w], dp[i][w - weights[i]] + values[i]].max
      else
        dp[i + 1][w] = dp[i][w]
      end
    end
  end
```

``dp[i + 1][w] = dp[i][w]``: i+1番目のアイテムの重量が許容重量wを超えている場合、i+1番目のアイテムを入れることはできないので、i+2番目までのアイテムを使用した際の最大重量とi+1番目までのアイテムを使用した最大重量が等しい。

# 前提条件
- ナップサックの各アイテムの重量の総和が容量を超えないこと。
- ナップサックの各アイテムの価値の総和が最大となること。

# 参考資料
- []()
