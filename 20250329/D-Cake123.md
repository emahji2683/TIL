# 解法の流れ
- ABCのそれぞれの種類のケーキの美味しさ一覧を取得する。
- 全パターンの美味しさ合計を投入する空配列を作成する。
- ABCの美味しさ一覧の配列に対して、3重のeach doを行い全パターンの美味しさ合計を算出する。
- 美味しさ全パターンの配列に対して、sortを行う。
- 出力する。

# 集合を扱うデータ型
キューとスタックがある。キューが末尾からデータを取り出すのに対して、スタックは先頭からデータを取り出す。

# ヒープとは
> 「子要素は親要素より常に大きいか等しい（または常に小さいか等しい）」という制約を持つ木構造の事。
> ヒープ (heap) は優先度付きキュー (priority queue) の実装の1つです。優先度付きキューは集合 (set) を扱うデータ型で、集合に含まれる要素が何らかの優先度 (priority) 順に取り出されるという特徴を持っています。

### **二分ヒープとは？**
二分ヒープ（Binary Heap）は、  
1. **完全二分木（Complete Binary Tree）** であり  
2. **ヒープ条件（Heap Property）** を満たすデータ構造  

です。  

二分ヒープには「最小ヒープ（Min Heap）」と「最大ヒープ（Max Heap）」の2種類があります。

---

## **1. 完全二分木とは？**
完全二分木とは、以下の条件を満たす二分木です。

- すべてのノードが **左から順に詰められている**（途中に隙間がない）
- **最下層を除き、すべてのレベルが完全に埋まっている**

### **例: 完全二分木**
```
      10
     /  \
    20   30
   /  \
  40   50
```
このように **左から順に埋める** ルールで構成されます。

---

## **2. ヒープ条件（Heap Property）とは？**
### **(A) 最小ヒープ（Min Heap）**
- 親ノードの値が子ノードの値より **常に小さい**
- **ルート（根）ノードが最小値**

#### **例: 最小ヒープ**
```
      10
     /  \
    20   30
   /  \
  40   50
```
- すべての親ノードが **子ノードより小さい**
- ルート（`10`）が **最小値**

#### **最小ヒープの特性**
- `pop` を呼び出すと、常に最小値が取り出される
- `push` を行うと、新しい値が適切な位置に挿入される

---

### **(B) 最大ヒープ（Max Heap）**
- 親ノードの値が子ノードの値より **常に大きい**
- **ルート（根）ノードが最大値**

#### **例: 最大ヒープ**
```
      50
     /  \
    30   20
   /  \
  10   5
```
- すべての親ノードが **子ノードより大きい**
- ルート（`50`）が **最大値**

#### **最大ヒープの特性**
- `pop` を呼び出すと、常に最大値が取り出される

---

## **3. 配列を使った二分ヒープの表現**
二分ヒープは **配列で効率よく表現** できます。  
ノードの **親子関係はインデックス計算で管理** します。

### **例: ヒープを配列で表す**
```
      10
     /  \
    20   30
   /  \
  40   50
```
この二分ヒープを **配列** にすると：
```ruby
heap = [10, 20, 30, 40, 50]
```
**親と子の関係（インデックス計算）**
- **親ノードのインデックス** `i`
  - **左の子**: `2 * i + 1`
  - **右の子**: `2 * i + 2`
- **子ノードのインデックス** `i`
  - **親**: `(i - 1) / 2`

#### **例: `heap = [10, 20, 30, 40, 50]` のインデックス対応**
| インデックス | 値 | 親のインデックス | 左の子のインデックス | 右の子のインデックス |
|--------------|----|------------------|----------------------|----------------------|
| 0            | 10 | -                | 1                    | 2                    |
| 1            | 20 | 0                | 3                    | 4                    |
| 2            | 30 | 0                | -                    | -                    |
| 3            | 40 | 1                | -                    | -                    |
| 4            | 50 | 1                | -                    | -                    |

---

## **4. 操作の詳細**
### **(1) `push`（要素の追加）**
1. 配列の **末尾** に要素を追加
2. `heapify_up` を実行し、**親ノードと比較して小さければ交換**
3. ルートまで繰り返す

#### **例**
```ruby
heap = [10, 20, 30, 40, 50]
heap.push(5) # 末尾に追加 → [10, 20, 30, 40, 50, 5]
```
```
      10
     /  \
    20   30
   /  \   /
  40   50 5
```
- `5 < 30` → `5` と `30` をスワップ
- `5 < 10` → `5` と `10` をスワップ

```
      5
     /  \
    20   10
   /  \   /
  40   50 30
```
最終的に `5` がルートに移動。

---

### **(2) `pop`（最小値の取り出し）**
1. ルートの要素（最小値）を取り出す
2. 配列の **最後の要素をルートに移動**
3. `heapify_down` を実行し、**子ノードと比較して小さい方と交換**
4. 末端まで繰り返す

#### **例**
```ruby
heap = [5, 20, 10, 40, 50, 30]
heap.pop # ルート（5）を取り出し、30 をルートへ
```
```
      30
     /  \
    20   10
   /  \
  40   50
```
- `30 > 10` → `30` と `10` をスワップ

```
      10
     /  \
    20   30
   /  \
  40   50
```
最終的に `10` がルートに収まる。

---

## **5. 計算量**
| 操作 | 計算量 |
|------|------|
| `push`（挿入） | **O(log n)**（`heapify_up` の高さ分だけ交換） |
| `pop`（最小値の削除） | **O(log n)**（`heapify_down` の高さ分だけ交換） |
| `peek`（最小値の取得） | **O(1)** |

---

## **6. 二分ヒープの用途**
- **優先度付きキュー**
  - タスクスケジューリング（CPUスケジューラなど）
  - ダイクストラ法（最短経路探索）
- **ソート（ヒープソート）**
  - `O(n log n)` の効率的なソート
- **データストリーム処理**
  - 例えば、「トップKの要素を求める」問題など

---

## **7. まとめ**
- **二分ヒープは完全二分木の形をしたデータ構造**
- **最小ヒープはルートが最小値、最大ヒープはルートが最大値**
- **配列を使って効率的に管理**
- **`push` は `heapify_up`、`pop` は `heapify_down` でヒープ条件を維持**
- **計算量は O(log n) なので高速**

もし、実装の詳細や応用についてもっと知りたいなら、質問してね！ 😊
